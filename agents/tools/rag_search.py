# -*- coding: utf-8 -*-
"""rag_search.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qCIPjphv1eXlpBLXSloYituxIMKtFvFY
"""

#!pip install chromadb

# rag_search.py

from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional
import chromadb
from chromadb.config import Settings
from sentence_transformers import SentenceTransformer

# -------------------------------------------------------------------------
# Configuration
# -------------------------------------------------------------------------
# Update this path to match the location of your vector_store folder
import os
from pathlib import Path

_BASE_DIR = Path(__file__).parent
PERSIST_DIR = str(_BASE_DIR / "data" / "chroma_toys")
COLLECTION_NAME = "products_toys"
EMBEDDING_MODEL_NAME = "BAAI/bge-large-en-v1.5"

_client = None
_collection = None
_model = None

# -------------------------------------------------------------------------
# Core Retrieval Logic (Engine)
# -------------------------------------------------------------------------
def get_resources():
    """Lazy-load Chroma collection and embedding model."""
    global _client, _collection, _model

    if _client is None:
        _client = chromadb.PersistentClient(path=PERSIST_DIR, settings=Settings())

    if _collection is None:
        _collection = _client.get_collection(COLLECTION_NAME)

    if _model is None:
        _model = SentenceTransformer(EMBEDDING_MODEL_NAME)

    return _collection, _model

def search_products(
    query: str,
    top_k: int = 5,
    max_price: float | None = None,
    min_rating: float | None = None,
    ingredient_contains: str | None = None,
):
    """
    Executes semantic search with metadata pre-filtering (price/rating)
    and post-filtering (ingredients).
    """
    collection, model = get_resources()
    query_embedding = model.encode([query]).tolist()

    # 1. Build Metadata Filters (Pre-filtering)
    conditions = []
    if max_price is not None:
        conditions.append({"price": {"$lte": float(max_price)}})
    if min_rating is not None:
        conditions.append({"rating": {"$gte": float(min_rating)}})

    if len(conditions) == 0:
        where_filter = None
    elif len(conditions) == 1:
        where_filter = conditions[0]
    else:
        where_filter = {"$and": conditions}

    # 2. Fetch results (Over-fetch if ingredient filter is active)
    fetch_k = top_k * 5 if ingredient_contains else top_k

    results = collection.query(
        query_embeddings=query_embedding,
        n_results=fetch_k,
        where=where_filter
    )

    # 3. Post-processing (Ingredient substring match)
    if ingredient_contains:
        filtered_ids = []
        filtered_metas = []
        filtered_dists = []

        if results['ids'] and len(results['ids'][0]) > 0:
            current_ids = results['ids'][0]
            current_metas = results['metadatas'][0]
            # Handle cases where distances might be missing
            current_dists = results.get('distances', [[0.0] * len(current_ids)])[0]

            count = 0
            for i in range(len(current_ids)):
                if count >= top_k: break

                meta = current_metas[i]
                ingreds = str(meta.get("ingredients", "")).lower()

                if ingredient_contains.lower() in ingreds:
                    filtered_ids.append(current_ids[i])
                    filtered_metas.append(meta)
                    filtered_dists.append(current_dists[i])
                    count += 1

            # Update results with filtered list
            results['ids'][0] = filtered_ids
            results['metadatas'][0] = filtered_metas
            if 'distances' in results:
                results['distances'][0] = filtered_dists

    elif results['ids'] and len(results['ids'][0]) > top_k:
         # Trim to requested top_k
         results['ids'][0] = results['ids'][0][:top_k]
         results['metadatas'][0] = results['metadatas'][0][:top_k]
         if results.get('distances'):
             results['distances'][0] = results['distances'][0][:top_k]

    return results

# -------------------------------------------------------------------------
# Data Models
# -------------------------------------------------------------------------
@dataclass
class RagSearchInput:
    query: str
    top_k: int = 5
    max_price: Optional[float] = None
    min_rating: Optional[float] = None
    brand: Optional[str] = None

@dataclass
class RagProduct:
    sku: str
    title: str
    price: Optional[float]
    rating: Optional[float]
    brand: Optional[str]
    category: Optional[str]
    doc_id: str
    score: Optional[float]

@dataclass
class RagSearchOutput:
    products: List[RagProduct]

# -------------------------------------------------------------------------
# MCP Tool Adapter
# -------------------------------------------------------------------------
def rag_search_tool(args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Entrypoint for the 'rag.search' tool.
    Maps arguments to the search engine and formats the output.
    """
    # 1. Parse Arguments
    params = RagSearchInput(
        query=args["query"],
        top_k=int(args.get("top_k", 5)),
        max_price=args.get("max_price"),
        min_rating=args.get("min_rating"),
        brand=args.get("brand"),
    )

    # 2. Augment Query (Include brand in semantic search)
    search_query = f"{params.brand} {params.query}" if params.brand else params.query

    # 3. Execute Search
    results = search_products(
        query=search_query,
        top_k=params.top_k,
        max_price=params.max_price,
        min_rating=params.min_rating
    )

    # 4. Format Output
    products: List[RagProduct] = []

    if results.get('ids') and results['ids'][0]:
        ids = results['ids'][0]
        metas = results['metadatas'][0]
        dists = results.get('distances', [[0.0] * len(ids)])[0]

        for i in range(len(ids)):
            meta = metas[i]
            dist = dists[i] if dists else 0.0

            p = RagProduct(
                sku=str(ids[i]),
                title=str(meta.get("title", "Unknown Title")),
                price=meta.get("price"),
                rating=meta.get("rating"),
                brand=meta.get("brand"),
                category=meta.get("category"),
                doc_id=str(ids[i]),
                score=float(dist)
            )
            products.append(p)

    return {
        "products": [asdict(p) for p in products]
    }

# -------------------------------------------------------------------------
# JSON Schemas
# -------------------------------------------------------------------------
RAG_SEARCH_INPUT_SCHEMA: Dict[str, Any] = {
    "type": "object",
    "title": "RagSearchInput",
    "properties": {
        "query": {
            "type": "string",
            "description": "Natural language query describing desired product(s).",
        },
        "top_k": {
            "type": "integer",
            "description": "Number of products to retrieve.",
            "default": 5,
            "minimum": 1,
            "maximum": 20,
        },
        "max_price": {
            "type": "number",
            "description": "Optional maximum price filter.",
        },
        "min_rating": {
            "type": "number",
            "description": "Optional minimum rating filter (0â€“5 scale).",
            "minimum": 0,
            "maximum": 5,
        },
        "brand": {
            "type": "string",
            "description": "Optional brand name filter.",
        },
    },
    "required": ["query"],
}

RAG_SEARCH_OUTPUT_SCHEMA: Dict[str, Any] = {
    "type": "object",
    "title": "RagSearchOutput",
    "properties": {
        "products": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "sku": {"type": "string"},
                    "title": {"type": "string"},
                    "price": {"type": ["number", "null"]},
                    "rating": {"type": ["number", "null"]},
                    "brand": {"type": ["string", "null"]},
                    "category": {"type": ["string", "null"]},
                    "doc_id": {"type": "string"},
                    "score": {"type": ["number", "null"]},
                },
                "required": ["sku", "title", "doc_id"],
            },
        }
    },
    "required": ["products"],
}

